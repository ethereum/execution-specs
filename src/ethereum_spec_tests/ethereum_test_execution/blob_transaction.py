"""Test execution format to get blobs from the execution client."""

from hashlib import sha256
from typing import ClassVar, Dict, List

from pytest import FixtureRequest

from ethereum_test_base_types import Address, Hash
from ethereum_test_base_types.base_types import Bytes
from ethereum_test_forks import Fork
from ethereum_test_rpc import BlobAndProofV1, BlobAndProofV2, EngineRPC, EthRPC
from ethereum_test_types import NetworkWrappedTransaction, Transaction, TransactionTestMetadata

from .base import BaseExecute


def versioned_hashes_with_blobs_and_proofs(
    tx: NetworkWrappedTransaction,
) -> Dict[Hash, BlobAndProofV1 | BlobAndProofV2]:
    """
    Return a dictionary of versioned hashes with their corresponding blobs and
    proofs.
    """
    versioned_hashes: Dict[Hash, BlobAndProofV1 | BlobAndProofV2] = {}
    for blob in tx.blob_objects:
        if isinstance(blob.proof, Bytes):
            versioned_hashes[blob.versioned_hash] = BlobAndProofV1(
                blob=blob.data, proof=blob.proof
            )
        elif isinstance(blob.proof, list):
            versioned_hashes[blob.versioned_hash] = BlobAndProofV2(
                blob=blob.data, proofs=blob.proof
            )
        else:
            raise ValueError(
                f"Blob with versioned hash {blob.versioned_hash.hex()} requires a proof "
                "that is not None"
            )

    return versioned_hashes


class BlobTransaction(BaseExecute):
    """
    Represents a test execution format to send blob transactions to the client and then
    use `engine_getBlobsV*` end points to validate the proofs generated by the execution client.
    """

    format_name: ClassVar[str] = "blob_transaction_test"
    description: ClassVar[str] = (
        "Send blob transactions to the execution client and validate their availability via "
        "`engine_getBlobsV*`"
    )
    requires_engine_rpc: ClassVar[bool] = True

    txs: List[NetworkWrappedTransaction | Transaction]

    def execute(
        self, fork: Fork, eth_rpc: EthRPC, engine_rpc: EngineRPC | None, request: FixtureRequest
    ):
        """Execute the format."""
        assert engine_rpc is not None, "Engine RPC is required for this format."
        versioned_hashes: Dict[Hash, BlobAndProofV1 | BlobAndProofV2] = {}
        sent_txs: List[Transaction] = []
        for tx_index, tx in enumerate(self.txs):
            if isinstance(tx, NetworkWrappedTransaction):
                tx.tx = tx.tx.with_signature_and_sender()
                sent_txs.append(tx.tx)
                expected_hash = tx.tx.hash
                versioned_hashes.update(versioned_hashes_with_blobs_and_proofs(tx))
                to_address = tx.tx.to
            else:
                tx = tx.with_signature_and_sender()
                sent_txs.append(tx)
                expected_hash = tx.hash
                to_address = tx.to
            label = to_address.label if isinstance(to_address, Address) else None
            metadata = TransactionTestMetadata(
                test_id=request.node.nodeid,
                phase="testing",
                target=label,
                tx_index=tx_index,
            )
            received_hash = eth_rpc.send_raw_transaction(tx.rlp(), request_id=metadata.to_json())
            assert expected_hash == received_hash, (
                f"Expected hash {expected_hash} does not match received hash {received_hash}."
            )
        version = fork.engine_get_blobs_version()
        assert version is not None, "Engine get blobs version is not supported by the fork."
        blob_response = engine_rpc.get_blobs(list(versioned_hashes.keys()), version=version)
        local_blobs_and_proofs = list(versioned_hashes.values())
        if len(blob_response) != len(local_blobs_and_proofs):
            raise ValueError(
                f"Expected {len(local_blobs_and_proofs)} blobs and proofs, "
                f"got {len(blob_response)}."
            )
        for expected_blob, received_blob in zip(
            local_blobs_and_proofs, blob_response.root, strict=False
        ):
            if received_blob is None:
                raise ValueError("Received blob is empty.")
            if isinstance(expected_blob, BlobAndProofV1):
                if not isinstance(received_blob, BlobAndProofV1):
                    raise ValueError("Received blob is not a BlobAndProofV1.")
                if expected_blob.blob != received_blob.blob:
                    raise ValueError("Blob mismatch.")
                if expected_blob.proof != received_blob.proof:
                    raise ValueError("Proof mismatch.")
            elif isinstance(expected_blob, BlobAndProofV2):
                if not isinstance(received_blob, BlobAndProofV2):
                    raise ValueError("Received blob is not a BlobAndProofV2.")
                if expected_blob.blob != received_blob.blob:
                    raise ValueError("Blob mismatch.")
                if expected_blob.proofs != received_blob.proofs:
                    error_message = "Proofs mismatch."
                    error_message += f"len(expected_blob.proofs) = {len(expected_blob.proofs)}, "
                    error_message += f"len(received_blob.proofs) = {len(received_blob.proofs)}\n"
                    if len(expected_blob.proofs) == len(received_blob.proofs):
                        index = 0

                        for expected_proof, received_proof in zip(
                            expected_blob.proofs, received_blob.proofs, strict=False
                        ):
                            if len(expected_proof) != len(received_proof):
                                error_message += f"Proof length mismatch. index = {index},"
                                error_message += f"expected_proof length = {len(expected_proof)}, "
                                error_message += f"received_proof length = {len(received_proof)}\n"
                                index += 1
                                continue
                            if expected_proof != received_proof:
                                error_message += f"Proof mismatch. index = {index},"
                                error_message += (
                                    f"expected_proof hash = {sha256(expected_proof).hexdigest()}, "
                                )
                                error_message += (
                                    f"received_proof hash = {sha256(received_proof).hexdigest()}\n"
                                )
                            index += 1
                    raise ValueError(error_message)
            else:
                raise ValueError(f"Unexpected blob type: {type(expected_blob)}")

        eth_rpc.wait_for_transactions(sent_txs)

#! /usr/bin/node

const headerBoilerPlate = `
# Check the intrinsic gas formula:
#
# 21000 + 16 * non-zero calldata bytes + 4 * zero calldata bytes +
# 1900 * access list storage key count + 2400 * access list address count
#
# Do not edit this file directly, it was created by
# tests/src/GeneralStateTestsFiller/stEIP1559/intrinsicGen.js


intrinsicCancun:

  _info:
    comment: Ori Pomerantz qbzzt1@gmail.com

  env:
    currentCoinbase: 2adc25665018aa1fe0e6bc666dac8fc2697ff9ba
    currentDifficulty: 0x20000
    currentGasLimit: 0xFF112233445566
    currentNumber: 1
    currentTimestamp: 1000
    currentBaseFee: 1000


  pre:
    cccccccccccccccccccccccccccccccccccccccc:
      balance: '1000000000000000000'
      code: |
          :yul london
          {
              sstore(0, add(1,1))
          }
      nonce: '0'
      storage: {}

    a94f5374fce5edbc8e2a8697c15331677e6ebf0b:
      balance: '1000000000000000000'
      code: '0x'
      nonce: 1
      storage: {}


  transaction:
    nonce: 1
    to: cccccccccccccccccccccccccccccccccccccccc
    value:
    - 0
    secretKey: "45a915e4d060149eb4365960e6a7a45f334393093061116b197e3240065ff2d8"
    maxFeePerGas: 1000
    maxPriorityFeePerGas: 100
`


// data for test cases
const dataList = [
    {gas:   0,     data: '0x' },
    {gas:   4,     data: '0x00' },
//  {gas:  16,     data: '0x00000000' },
    {gas:  16,     data: '0xFF'},
    {gas:  20,     data: '0x00FF' },
//  {gas:  20,     data: '0x00FE' },
//  {gas:  20,     data: '0xFF00' },
//  {gas:  20,     data: '0xFE00' },
//  {gas: 256,     data: '0x0102030405060708090A0B0C0D0E0F10'},
    {gas: 512,     data: '0x0102030405060708090A0B0C0D0E0F101112131415161718191a1b1c1d1e1f20'},
//  {gas: 244,     data: '0x000102030405060708090A0B0C0D0E0F'},
    {gas: 500,     data: '0x000102030405060708090A0B0C0D0E0F101112131415161718191a1b1c1d1e1f'}
]    // dataList



// accessLists for test cases
const accessListList = [
  {gas:      0, accessList: '[]'},
  {gas:   2400, accessList: `
      - address: 0xF00000000000000000000000000000000000F101
        storageKeys: []
  `},
  {gas:   4800, accessList: `
      - address: 0xF00000000000000000000000000000000000F101
        storageKeys: []
      - address: 0xF00000000000000000000000000000000000F102
        storageKeys: []
  `},
  {gas:   4300, accessList: `
      - address: 0xF00000000000000000000000000000000000F101
        storageKeys:
        - 0x60A7
  `},
// {gas:   6700, accessList: `
//     - address: 0xF00000000000000000000000000000000000F101
//       storageKeys:
//       - 0x60A7
//     - address: 0xF00000000000000000000000000000000000F102
//       storageKeys: []
// `},
// {gas:   6200, accessList: `
//     - address: 0xF00000000000000000000000000000000000F101
//       storageKeys:
//       - 0x60A7
//       - 0xBEEF
// `},
// {gas:   8600, accessList: `
//     - address: 0xF00000000000000000000000000000000000F101
//       storageKeys:
//       - 0x60A7
//     - address: 0xF00000000000000000000000000000000000F102
//       storageKeys:
//       - 0xBEEF
// `},
  {gas:   8600, accessList: `
      - address: 0xF00000000000000000000000000000000000F101
        storageKeys:
        - 0x60A7
        - 0xBEEF
      - address: 0xF00000000000000000000000000000000000F102
        storageKeys: []
  `}
]   // accessListList


let testCases = []


// Create test cases for every data and accessList combo
for(let i=0; i<dataList.length; i++)
  for (let j=0; j<accessListList.length; j++)
    testCases.push({
      gas: 21000 + dataList[i].gas + accessListList[j].gas,
      data: dataList[i].data,
      accessList: accessListList[j].accessList
    })



// The limits at which it makes sense to check intrinsic costs. We need this list
// later to figure out what min<n> labels we have
const gasLimits = [...new Set(testCases.map(x => x.gas))]

// We also want to check at exactly one less
const allGasLimits = gasLimits.concat(gasLimits.map(x => x-1))



const gasLimitText =
        allGasLimits.map(x => `    - ${x}\n`).reduce((a,b) => a+b, "    gasLimit:\n")



// Convert a test case into something we can put in the data list of the
// transaction
const testCase2Data = testCase => `
    - data: :label min${testCase.gas} :raw ${testCase.data}
      accessList: ${testCase.accessList}`   // testCase2Data


const dataText = testCases.map(testCase2Data).reduce((a,b) => a+b, "    data:\n")


// Get the expect: section for a specific gas limit.
const getExpect = i => {
  const gasLimit = allGasLimits[i]

  const tooLow = gasLimits.filter(x => x >  gasLimit)
  const okList = gasLimits.filter(x => x <= gasLimit)

  const dataList = list => list.map(x => `        - :label min${x}\n`).reduce((a,b) => a+b, "")

  let tooLowText = ""
  let okListText = ""

  if (tooLow.length > 0)
     tooLowText = `
  # Failure with gas limit ${gasLimit}
  - indexes:
      data:
${dataList(tooLow)}
      gas:
      - !!int ${i}
      value: !!int -1

    network:
      - 'Cancun'
    expectException:
      'Cancun': TransactionException.INTRINSIC_GAS_TOO_LOW
    result: {}
`   // if tooLow.length > 0


  if (okList.length > 0)
     okListText = `
  # Success with gas limit ${gasLimit}
  - indexes:
      data:
${dataList(okList)}
      gas:  !!int ${i}
      value: !!int -1

    network:
      - 'Cancun'
    result: {}
`   // if tooLow.length > 0

   return tooLowText + "\n" + okListText
}  // getExpect





console.log(headerBoilerPlate)
console.log(gasLimitText)
console.log(dataText)
console.log('\n\n\n\n  expect:\n')
for(var i=0; i<allGasLimits.length; i++)
  console.log(getExpect(i))

"""Common utilities for the Identity Precompile tests."""

from dataclasses import dataclass
from typing import Tuple

from pydantic import BaseModel

from ethereum_test_base_types.composite_types import Storage
from ethereum_test_tools import (
    Bytecode,
)
from ethereum_test_tools import Opcodes as Op


@dataclass(frozen=True)
class Constants:
    """Constants for the Identity Precompile."""

    IDENTITY_PRECOMPILE_ADDRESS = 0x04


class CallArgs(BaseModel):
    """Defines inputs to CALL for the Identity precompile."""

    address: int = Constants.IDENTITY_PRECOMPILE_ADDRESS
    gas: int = 0x1F4
    value: int = 0x0
    args_offset: int = 0x0
    args_size: int = 0x20
    ret_offset: int = 0x0
    ret_size: int = 0x20


def generate_identity_call_bytecode(
    storage: Storage,
    call_type: Op,
    memory_values: Tuple[int, ...],
    call_args: CallArgs,
    call_succeeds: bool,
) -> Bytecode:
    """
    Generate bytecode for calling the identity precompile with given memory values.

    Args:
        storage (Storage): The storage object to use for storing values.
        call_type (Op): The type of call opcode (CALL or CALLCODE).
        memory_values (Tuple[int, ...]): Values to store in memory before the call.
        call_args (CallArgs): Arguments for the CALL opcode.
        call_succeeds (bool): Whether the call should succeed or not.

    Returns:
        Bytecode: The generated bytecode for the identity precompile call.

    """
    code = Bytecode()

    # Store provided values in memory
    mstore_count = len(memory_values) if memory_values else 0
    mstore_offset = 0
    mstore_value = 0
    if mstore_count:
        for i, value in enumerate(memory_values):
            mstore_value = value
            code += Op.MSTORE(mstore_offset, mstore_value)
            if mstore_count > i + 1:
                mstore_offset += 0x20

    # Call the identity precompile, then check that the last value in memory has not changed
    code += (
        Op.SSTORE(
            storage.store_next(call_succeeds),
            call_type(**call_args.model_dump()),
        )
        + Op.SSTORE(storage.store_next(mstore_value), Op.MLOAD(mstore_offset))
        + Op.STOP
    )

    return code

"""CLI tool to generate mypy stub files for EIPChecklist classes."""

import sys
from pathlib import Path

import click


def has_nested_classes(obj) -> bool:
    """Check if an object has nested classes with _path attribute."""
    for attr_name in dir(obj):
        if attr_name.startswith("_"):
            continue
        attr = getattr(obj, attr_name)
        if isinstance(attr, type) and hasattr(attr, "_path"):
            return True
    return False


def generate_class_stub(obj, class_name: str, indent: int = 0) -> list[str]:
    """Generate stub for a class and its nested classes."""
    lines = []
    spaces = "    " * indent

    # Get all attributes that are classes with _path
    nested_classes = []
    leaf_classes = []

    for attr_name in dir(obj):
        if attr_name.startswith("_"):
            continue

        attr = getattr(obj, attr_name)
        if isinstance(attr, type) and hasattr(attr, "_path"):
            if has_nested_classes(attr):
                nested_classes.append((attr_name, attr))
            else:
                leaf_classes.append(attr_name)

    # Determine if this class itself should be callable
    is_callable = class_name != "EIPChecklist"  # All classes except the root are callable

    # Generate class declaration
    if is_callable:
        lines.append(f"{spaces}class {class_name}(_CallableChecklistItem):")
    else:
        lines.append(f"{spaces}class {class_name}:")

    # If no nested content, add pass
    if not nested_classes and not leaf_classes:
        lines.append(f"{spaces}    pass")
        return lines

    # Generate leaf classes (final callable items)
    for attr_name in sorted(leaf_classes):
        lines.append(f"{spaces}    {attr_name}: _CallableChecklistItem")

    # Add blank line if we have both leaf classes and nested classes
    if leaf_classes and nested_classes:
        lines.append("")

    # Generate nested classes
    for i, (attr_name, attr_obj) in enumerate(sorted(nested_classes)):
        if i > 0:  # Add blank line between nested classes
            lines.append("")
        nested_lines = generate_class_stub(attr_obj, attr_name, indent + 1)
        lines.extend(nested_lines)

    return lines


@click.command()
@click.option(
    "--output",
    "-o",
    type=click.Path(),
    help="Output path for the stub file (default: auto-detect)",
)
@click.option(
    "--dry-run",
    is_flag=True,
    help="Print the generated stub content instead of writing to file",
)
def generate_checklist_stubs(output: str | None, dry_run: bool) -> None:
    """
    Generate mypy stub files for EIPChecklist classes.

    This is a development tool that generates .pyi stub files to help mypy
    understand that EIPChecklist classes are callable, fixing type checking issues.

    Examples:
        # Generate stub files (auto-detect location)
        uv run generate_checklist_stubs

        # Generate to specific location
        uv run generate_checklist_stubs --output /path/to/stubs.pyi

        # Preview content without writing
        uv run generate_checklist_stubs --dry-run

    """
    try:
        # Add src to path so we can import the module
        src_path = Path(__file__).parent.parent
        sys.path.insert(0, str(src_path))

        from ethereum_test_checklists.eip_checklist import EIPChecklist

        stub_content = '''"""
Type stubs for EIP checklist - auto-generated.

DO NOT EDIT MANUALLY - This file is generated by `uv run generate_checklist_stubs`
"""

from typing import Any, Callable, TypeVar, overload

import pytest

F = TypeVar("F", bound=Callable[..., Any])

class _CallableChecklistItem:
    """Base type for all callable checklist items."""

    @overload
    def __call__(self, func: F) -> F: ...
    @overload
    def __call__(self, *, eip: Any = ..., **kwargs: Any) -> pytest.MarkDecorator: ...
    def __str__(self) -> str: ...

'''

        # Generate the main EIPChecklist structure
        lines = generate_class_stub(EIPChecklist, "EIPChecklist", indent=0)
        stub_content += "\n".join(lines) + "\n"

        if dry_run:
            click.echo("Generated stub content:")
            click.echo("=" * 50)
            click.echo(stub_content)
            return

        # Determine output path
        if output:
            stub_path = Path(output)
        else:
            stub_path = src_path / "ethereum_test_checklists" / "eip_checklist.pyi"

        # Write to the stub file
        stub_path.parent.mkdir(parents=True, exist_ok=True)
        stub_path.write_text(stub_content)

        click.echo(f"âœ… Generated stub file: {stub_path}")
        click.echo(f"ğŸ“Š Total lines: {len(stub_content.splitlines())}")

        # Count classes for verification
        class_count = stub_content.count("class ")
        callable_count = stub_content.count(": _CallableChecklistItem")
        click.echo(f"ğŸ—ï¸  Classes: {class_count}, Callable items: {callable_count}")

        click.echo(
            "\nğŸ’¡ This stub file helps mypy understand that EIPChecklist classes are callable."
        )
        click.echo(
            "   You can now use @EIPChecklist.Opcode.Test.StackComplexOperations() "
            "without type errors!"
        )

    except ImportError as e:
        click.echo(f"âŒ Error importing EIPChecklist: {e}", err=True)
        click.echo("ğŸ’¡ Make sure you're running this from the project root", err=True)
        sys.exit(1)
    except Exception as e:
        click.echo(f"âŒ Error generating stubs: {e}", err=True)
        sys.exit(1)


if __name__ == "__main__":
    generate_checklist_stubs()

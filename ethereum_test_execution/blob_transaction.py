"""Test execution format to get blobs from the execution client."""

from typing import ClassVar, Dict, List

from ethereum_test_base_types import Hash
from ethereum_test_forks import Fork
from ethereum_test_rpc import BlobAndProofV1, BlobAndProofV2, EngineRPC, EthRPC
from ethereum_test_types import NetworkWrappedTransaction, Transaction

from .base import BaseExecute


def versioned_hashes_with_blobs_and_proofs(
    tx: NetworkWrappedTransaction,
) -> Dict[Hash, BlobAndProofV1 | BlobAndProofV2]:
    """
    Return a dictionary of versioned hashes with their corresponding blobs and
    proofs.
    """
    versioned_hashes: Dict[Hash, BlobAndProofV1 | BlobAndProofV2] = {}
    for blob in tx.blobs:
        versioned_hash = blob.versioned_hash()
        if blob.kzg_proof is not None:
            versioned_hashes[versioned_hash] = BlobAndProofV1(blob=blob.data, proof=blob.kzg_proof)
        elif blob.kzg_cell_proofs is not None:
            versioned_hashes[versioned_hash] = BlobAndProofV2(
                blob=blob.data, proofs=blob.kzg_cell_proofs
            )
        else:
            raise ValueError(
                f"Blob with versioned hash {versioned_hash.hex()} requires either kzg_proof "
                "or kzg_cell_proofs, but both are None"
            )

    return versioned_hashes


class BlobTransaction(BaseExecute):
    """
    Represents a test execution format to send blob transactions to the client and then
    use `engine_getBlobsV*` end points to validate the proofs generated by the execution client.
    """

    format_name: ClassVar[str] = "blob_transaction_test"
    description: ClassVar[str] = (
        "Send blob transactions to the execution client and validate their availability via "
        "`engine_getBlobsV*`"
    )
    requires_engine_rpc: ClassVar[bool] = True

    txs: List[NetworkWrappedTransaction | Transaction]

    def execute(self, fork: Fork, eth_rpc: EthRPC, engine_rpc: EngineRPC | None):
        """Execute the format."""
        assert engine_rpc is not None, "Engine RPC is required for this format."
        versioned_hashes: Dict[Hash, BlobAndProofV1 | BlobAndProofV2] = {}
        sent_txs: List[Transaction] = []
        for tx in self.txs:
            if isinstance(tx, NetworkWrappedTransaction):
                tx.tx = tx.tx.with_signature_and_sender()
                sent_txs.append(tx.tx)
                expected_hash = tx.tx.hash
                versioned_hashes.update(versioned_hashes_with_blobs_and_proofs(tx))
            else:
                tx = tx.with_signature_and_sender()
                sent_txs.append(tx)
                expected_hash = tx.hash
            received_hash = eth_rpc.send_raw_transaction(tx.rlp())
            assert expected_hash == received_hash, (
                f"Expected hash {expected_hash} does not match received hash {received_hash}."
            )
        version = fork.engine_get_blobs_version()
        assert version is not None, "Engine get blobs version is not supported by the fork."
        blob_response = engine_rpc.get_blobs(list(versioned_hashes.keys()), version=version)
        local_blobs_and_proofs = list(versioned_hashes.values())
        if len(blob_response) != len(local_blobs_and_proofs):
            raise ValueError(
                f"Expected {len(local_blobs_and_proofs)} blobs and proofs, "
                f"got {len(blob_response)}."
            )
        for expected_blob, received_blob in zip(
            local_blobs_and_proofs, blob_response.root, strict=False
        ):
            if received_blob is None:
                raise ValueError("Received blob is empty.")
            if isinstance(expected_blob, BlobAndProofV1):
                if not isinstance(received_blob, BlobAndProofV1):
                    raise ValueError("Received blob is not a BlobAndProofV1.")
                if expected_blob.blob != received_blob.blob:
                    raise ValueError("Blob mismatch.")
                if expected_blob.proof != received_blob.proof:
                    raise ValueError("Proof mismatch.")
            elif isinstance(expected_blob, BlobAndProofV2):
                if not isinstance(received_blob, BlobAndProofV2):
                    raise ValueError("Received blob is not a BlobAndProofV2.")
                if expected_blob.blob != received_blob.blob:
                    raise ValueError("Blob mismatch.")
                if expected_blob.proofs != received_blob.proofs:
                    raise ValueError("Proofs mismatch.")
            else:
                raise ValueError(f"Unexpected blob type: {type(expected_blob)}")

        eth_rpc.wait_for_transactions(sent_txs)
